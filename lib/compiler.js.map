{"version":3,"sources":["../src/compiler.js"],"names":["isCallNode","node","type","isQuotNode","isModuleNode","name","isImportNode","isExportNode","isVarNode","isPartialNode","isCall","x","Call","isQuot","Quot","isVar","Var","NOOP","__noop","Context","constructor","props","core","modules","stack","length","scope","refsToResolve","addVar","count","v","index","lastItem","append","addModule","ref","prefix","addImport","ns","loc","cx","run","pipe","module","Object","entries","forEach","k","next","complete","addExport","qname","body","Error","undefined","apply","self","args","keys","call","bind","getRef","hasOwnProperty","isBoundQname","getVarRef","setVarRef","value","addCall","isDef","addDatum","item","push","len","i","$o","last","pop","_args","splice","ret","subscribe","isParam","isAssig","Observable","create","hasType","unshift","prepare","path","jsArray","a","local","compile","o","quots","refNode","dest","target","depth","first","$_","parent","runnable","toVNodeStream","str","runString"],"mappings":"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","sourcesContent":["// TODO detect AND/OR and convert to quotation\r\nimport { isLeaf, isBranch, isClose, toVNodeStream } from \"l3n\";\r\nimport { parse, parseString } from \"./parser\";\r\nimport { prefixAndName, normalizeName } from \"./compiler-util\";\r\nimport { Observable, isObservable, pipe } from \"rxjs\";\r\nimport { reduce, map, switchMap, mergeMap } from \"rxjs/operators\";\r\nimport { $_ /*, papplyAny*/ } from \"./papply\";\r\n\r\n//const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\r\n\r\n//const ifRe = /^(n:)?if$/;\r\n//const andRe = /^(n:)?and$/;\r\n//const orRe = /^(n:)?or$/;\r\n//const andOrRe = /^(n\\.)?(and|or)$/;\r\n\r\nconst isCallNode = node => node && node.type == 14;\r\nconst isQuotNode = node => node && node.type == 15;\r\n//const isSeqNode = node => isCallNode(node) && node.name === \"\";\r\nconst isModuleNode = node => isCallNode(node) && node.name === \"$*\";\r\nconst isImportNode = node => isCallNode(node) && node.name === \"$<\";\r\nconst isExportNode = node => isCallNode(node) && node.name === \"$>\";\r\nconst isVarNode = node => isCallNode(node) && node.name === \"$\";\r\nconst isPartialNode = node => isCallNode(node) && node.name == \"$_\";\r\n//const isRecursivePartialNode = node => isCallNode(node) && node.name == \"$.\";\r\n//const isIfNode = node => isCallNode(node) && ifRe.test(node.name);\r\n//const isAndNode = node => isCallNode(node) && andRe.test(node.name);\r\n//const isOrNode = node => isCallNode(node) && orRe.test(node.name);\r\n\r\nconst isCall = x => x && x instanceof Call;\r\nconst isQuot = x => x && x instanceof Quot;\r\nconst isVar = x => x && x instanceof Var;\r\n//const isParam = x => x && x instanceof Var && x.isParam;\r\nconst NOOP = {__noop:true};\r\n\r\n// TODO module namespace\r\nclass Context {\r\n\tconstructor(props = {}) {\r\n\t\tthis.core = props.core;\r\n\t\tthis.modules = props.modules || {};\r\n\t\tthis.stack = [];\r\n\t\tthis.length = 0;\r\n\t\tthis.scope = {};\r\n\t\tthis.refsToResolve = {};\r\n\t}\r\n\taddVar(count){\r\n\t\tlet v;\r\n\t\tif(count > 1) {\r\n\t\t\t// assigment\r\n\t\t\tv = new Var(this,1,count);\r\n\t\t} else {\r\n\t\t\tconst index = this.stack.lastItem;\r\n\t\t\tif(typeof index == \"number\") {\r\n\t\t\t\tthis.length++;\r\n\t\t\t\tv = new Var(this,2,1);\r\n\t\t\t} else {\r\n\t\t\t\tv = new Var(this,3,1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.append(v);\r\n\t}\r\n\taddModule(length) {\r\n\t\tconst ref = prefix => {\r\n\t\t\tthis.modules[prefix] = {};\r\n\t\t\treturn NOOP;\r\n\t\t};\r\n\t\tthis.append(new Call(\"module\",length,ref));\r\n\t}\r\n\taddImport(length) {\r\n\t\tconst ref = (prefix,ns,loc) => {\r\n\t\t\tif(length == 2) loc = ns;\r\n\t\t\tthis.refsToResolve[prefix] = {};\r\n\t\t\t// TODO merge properly\r\n\t\t\tconst cx = this;\r\n\t\t\treturn run(\"../raddled/\"+loc+\".rdl\")(cx).pipe(map(() => {\r\n\t\t\t\tconst module = cx.modules[prefix];\r\n\t\t\t\tObject.entries(cx.refsToResolve[prefix]).forEach(([k,v]) => {\r\n\t\t\t\t\tv.next(module[k]);\r\n\t\t\t\t\tv.complete();\r\n\t\t\t\t});\r\n\t\t\t\treturn cx;\r\n\t\t\t}));\r\n\t\t};\r\n\t\tthis.append(new Call(\"import\",length,ref));\r\n\t}\r\n\taddExport(length){\r\n\t\tconst ref = (qname,type,body) => {\r\n\t\t\tconst { prefix, name } = normalizeName(qname);\r\n\t\t\tconst module = this.modules[prefix];\r\n\t\t\tif(!module) throw new Error(`Module \"${prefix}\" has not been formally declared`);\r\n\t\t\tif(body === undefined) {\r\n\t\t\t\t// bind in core\r\n\t\t\t\tbody = this.core[name];\r\n\t\t\t\tif(body) module[name] = type(body);\r\n\t\t\t} else if(isQuot(body)) {\r\n\t\t\t\t// add a function that serves as a proxy (i.e. can be applied)\r\n\t\t\t\tif(!module[name]) {\r\n\t\t\t\t\tmodule[name] = {\r\n\t\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\t\tconst ref = this[args.length];\r\n\t\t\t\t\t\t\tif(!ref) throw new Error(`Incorrect number of parameters for ${qname}, received ${args.length}, have ${Object.keys(this)}`);\r\n\t\t\t\t\t\t\treturn type(ref.call.bind(ref,self))(...args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tmodule[name][body.length] = body;\r\n\t\t\t} else {\r\n\t\t\t\tmodule[name] = type(body);\r\n\t\t\t}\r\n\t\t\t// perhaps we should just return the export / thing itself\r\n\t\t\treturn NOOP;\r\n\t\t};\r\n\t\tthis.append(new Call(\"export\",length,ref));\r\n\t}\r\n\tgetRef(qname) {\r\n\t\tconst modules = this.modules;\r\n\t\tconst core = this.core;\r\n\t\tconst { prefix, name } = normalizeName(qname,\"n\");\r\n\t\tif(modules.hasOwnProperty(prefix)) {\r\n\t\t\tconst ref = modules[prefix][name];\r\n\t\t\tif(ref) return ref;\r\n\t\t\tif(prefix === \"n\" && core[name]) return core[name];\r\n\t\t\tthrow new Error(`Could not resolve ${name} in module ${prefix}`);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"no module found: \"+prefix);\r\n\t\t}\r\n\t}\r\n\tisBoundQname(qname) {\r\n\t\tconst { prefix } = prefixAndName(qname);\r\n\t\treturn this.modules.hasOwnProperty(prefix) || this.refsToResolve.hasOwnProperty(prefix);\r\n\t}\r\n\tgetVarRef(qname) {\r\n\t\t// ignore NS to see if we have prefix\r\n\t\tif(this.isBoundQname(qname)) return this.getRef(qname);\r\n\t\treturn this.scope[qname];\r\n\t}\r\n\tsetVarRef(qname,type,value) {\r\n\t\tthis.scope[qname] = value;\r\n\t\treturn NOOP;\r\n\t}\r\n\taddCall(qname,length,isDef) {\r\n\t\t//if(!qname) console.trace(qname,length);\r\n\t\tthis.append(new Call(qname,length,undefined,isDef));\r\n\t}\r\n\taddDatum(type,value) {\r\n\t\tif(type !== 8) this.append(value);\r\n\t}\r\n\tappend(item){\r\n\t\tthis.stack.push(item);\r\n\t}\r\n\tapply(self,args){\r\n\t\t// TODO\r\n\t\t// - first arg is external?\r\n\t\t// - prevent recursion\r\n\t\t// - prevent type checks: just use method for stack/next on each type\r\n\t\t// evaluation stack\r\n\t\tvar stack = [];\r\n\t\tconst len = this.stack.length;\r\n\t\t//for(let i = 0, len = this.stack.length; i < len; i++) {\r\n\t\tconst next = (i,$o) => {\r\n\t\t\tif(i === len) {\r\n\t\t\t\tconst last = stack.pop();\r\n\t\t\t\tif($o) {\r\n\t\t\t\t\t$o.next(last);\r\n\t\t\t\t\t$o.complete();\r\n\t\t\t\t\treturn $o;\r\n\t\t\t\t}\r\n\t\t\t\treturn last;\r\n\t\t\t}\r\n\t\t\tconst last = this.stack[i];\r\n\t\t\tif(isQuot(last)) {\r\n\t\t\t\tstack.push(last.call.bind(last,this));\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t} else if(isCall(last)) {\r\n\t\t\t\tconst len = last.length;\r\n\t\t\t\tif(stack.length < len) throw new Error(\"Stack underflow\");\r\n\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\tconst ret = last.apply(this,_args);\r\n\t\t\t\tif(last.qname == \"import\") {\r\n\t\t\t\t\tret.subscribe({\r\n\t\t\t\t\t\tcomplete(){\r\n\t\t\t\t\t\t\tnext(i+1,$o);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(ret !== NOOP) stack.push(ret);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else if(isVar(last)) {\r\n\t\t\t\tif(last.isParam) {\r\n\t\t\t\t\t// pop the index, push the arg\r\n\t\t\t\t\tconst index = stack.pop();\r\n\t\t\t\t\tstack.push(args[index - 1]);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// treat vars as Calls\r\n\t\t\t\t\tconst len = last.length;\r\n\t\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\t\tconst ref = last.apply(self,_args);\r\n\t\t\t\t\tif(!last.isAssig) {\r\n\t\t\t\t\t\tstack.push(ref);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstack.push(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(last);\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t}\r\n\t\t};\r\n\t\tif(isQuot(this)) {\r\n\t\t\treturn next(0);\r\n\t\t} else {\r\n\t\t\treturn Observable.create($o => {\r\n\t\t\t\tnext(0,$o);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tcall(self,...args) {\r\n\t\treturn this.apply(self,args);\r\n\t}\r\n}\r\nclass Var {\r\n\tconstructor(cx,type,length) {\r\n\t\tthis.cx = cx;\r\n\t\t// 1. assignment\r\n\t\t// 2. param\r\n\t\t// 3. var\r\n\t\tthis.isAssig = type == 1;\r\n\t\tthis.isParam = type == 2;\r\n\t\tthis.length = length;\r\n\t}\r\n\tapply(self,args) {\r\n\t\tif(this.isAssig) {\r\n\t\t\tconst hasType = args.length > 2;\r\n\t\t\treturn this.cx.setVarRef(args[0], hasType ? args[1] : null, hasType ? args[2] : args[1]);\r\n\t\t} else {\r\n\t\t\treturn this.cx.getVarRef(args[0]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Quot extends Context {\r\n}\r\n\r\nclass Call {\r\n\tconstructor(qname,length,ref,isDef) {\r\n\t\tthis.qname = qname;\r\n\t\tthis.length = length;\r\n\t\tthis.ref = ref;\r\n\t\tthis.isDef = isDef;\r\n\t}\r\n\tapply(cx,args) {\r\n\t\tconst ref = this.ref || cx.getRef(this.qname,this.length);\r\n\t\t// TODO generalize...\r\n\t\tif(this.isDef) {\r\n\t\t\targs.unshift(this.isDef);\r\n\t\t}\r\n\t\treturn ref.apply(this,args);\r\n\t}\r\n}\r\n\r\nexport const prepare = (core,prefix=\"n\",path=\"../raddled/\") => {\r\n\t// pre-compile core\r\n\tcore.jsArray = (...a) => a;\r\n\tconst cx = new Context({core:core,modules:{local:{}}});\r\n\treturn run(path+prefix+\".rdl\")(cx).pipe(map(() => cx));\r\n};\r\n\r\nexport const compile = cx => o => {\r\n\tcx = new Context(cx);\r\n\tconst quots = [cx];\r\n\t// this is a reduction into a single result\r\n\treturn o.pipe(reduce((cx,node) => {\r\n\t\tconst type = node.type;\r\n\t\tif(isClose(type)) {\r\n\t\t\tconst refNode = node.node;\r\n\t\t\tif(isQuotNode(refNode)) {\r\n\t\t\t\tconst dest = quots.pop();\r\n\t\t\t\tquots.lastItem.append(dest);\r\n\t\t\t} else {\r\n\t\t\t\tconst target = quots.lastItem;\r\n\t\t\t\tif(isVarNode(refNode)) {\r\n\t\t\t\t\t// var or param\r\n\t\t\t\t\tconst count = refNode.count();\r\n\t\t\t\t\t// TODO add default prefix\r\n\t\t\t\t\t// NOTE we know the first child on the node, so we can read the name there\r\n\t\t\t\t\t// HOWEVER this goes against the pure stack-based implementation\r\n\t\t\t\t\tif(count > 1 && refNode.depth == 1 && target.isBoundQname(refNode.first())) {\r\n\t\t\t\t\t\t// private top-level declaration, simply add as export\r\n\t\t\t\t\t\ttarget.addExport(count);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget.addVar(count);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(isModuleNode(refNode)) {\r\n\t\t\t\t\t// handle module insertion\r\n\t\t\t\t\ttarget.addModule(refNode.count());\r\n\t\t\t\t} else if(isImportNode(refNode)) {\r\n\t\t\t\t\t// handle import\r\n\t\t\t\t\ttarget.addImport(refNode.count());\r\n\t\t\t\t} else if(isExportNode(refNode)) {\r\n\t\t\t\t\t// handle export\r\n\t\t\t\t\t// expect type to be compiled to a single Call\r\n\t\t\t\t\ttarget.addExport(refNode.count());\r\n\t\t\t\t} else if(isPartialNode(refNode)) {\r\n\t\t\t\t\t// partial any\r\n\t\t\t\t\ttarget.append($_);\r\n\t\t\t\t} else if(isCallNode(refNode)){\r\n\t\t\t\t\t// handle call\r\n\t\t\t\t\tlet name = refNode.name;\r\n\t\t\t\t\tlet isDef;\r\n\t\t\t\t\t// TODO generalize\r\n\t\t\t\t\t// Use array and seq indifferently\r\n\t\t\t\t\t// and always apply interop higher-order functions.\r\n\t\t\t\t\t// Functions from implementation provide seqs\r\n\t\t\t\t\t// while inline stuff is just arrays\r\n\t\t\t\t\tif(name == \"function\") {\r\n\t\t\t\t\t\tname = \"def\";\r\n\t\t\t\t\t\tisDef = refNode.parent.first();\r\n\t\t\t\t\t\tif(typeof isDef !== \"string\") isDef = \"_\";\r\n\t\t\t\t\t} else if(name == \"\") {\r\n\t\t\t\t\t\tif(refNode.parent.name == \"function\") {\r\n\t\t\t\t\t\t\tname = \"jsArray\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tname = \"seq\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget.addCall(name,refNode.count(),isDef);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if(isLeaf(type)) {\r\n\t\t\tquots.lastItem.addDatum(node.type,node.value);\r\n\t\t} else if(isBranch(type) && isQuotNode(node)) {\r\n\t\t\t// add quot to scope stack\r\n\t\t\tquots.push(new Quot(cx));\r\n\t\t}\r\n\t\treturn cx;\r\n\t},cx));\r\n};\r\n\r\nconst runnable = cx => pipe(toVNodeStream,compile(cx),switchMap(cx => cx.apply()),mergeMap(x => isObservable(x) ? x : [x]));\r\nexport const run = str => cx => runnable(cx)(parse(str));\r\nexport const runString = str => cx => runnable(cx)(parseString(str));\r\n"],"file":"compiler.js"}