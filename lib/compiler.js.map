{"version":3,"sources":["../src/compiler.js"],"names":["isCallNode","node","type","isQuotNode","isElementNode","isListNode","isMapNode","isModuleNode","name","isImportNode","isExportNode","isVarNode","isPartialNode","isCall","x","Call","isQuot","Quot","isVar","Var","isDatum","Datum","constructor","value","length","apply","Context","props","core","modules","path","prefix","namespace","stack","scope","addVar","count","v","index","lastItem","append","addModule","ref","ns","moduleMap","addImport","loc","remap","ret","run","pipe","cx","Object","assign","addExport","qname","body","module","Error","undefined","__length","self","args","keys","call","bind","getRef","has","hasOwnProperty","isBoundQname","getVarRef","setVarRef","addCall","isDef","addDatum","item","push","len","next","i","$o","last","pop","complete","_args","splice","a","subscribe","isParam","isAssig","Observable","create","hasType","unshift","concat","prepare","null","l3","compile","o","quots","refNode","dest","target","depth","first","$_","parent","key","runnable","withAttrs","runString","str"],"mappings":"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","sourcesContent":["// TODO detect AND/OR and convert to quotation\r\nimport { isLeaf, isBranch, isClose, toVNodeStreamCurried } from \"l3n\";\r\nimport * as l3 from \"l3n\";\r\nimport { parse, parseString } from \"./parser\";\r\nimport { prefixAndName, normalizeName } from \"./compiler-util\";\r\nimport { Observable, isObservable, pipe } from \"rxjs\";\r\nimport { reduce, switchMap, mergeMap } from \"rxjs/operators\";\r\nimport { $_ /*, papplyAny*/ } from \"./papply\";\r\n\r\nconst isCallNode = node => node.type == 14;\r\nconst isQuotNode = node => node.type == 15;\r\nconst isElementNode = node => node.type == 1;\r\nconst isListNode = node => node.type == 5;\r\nconst isMapNode = node => node.type == 6;\r\n//const isSeqNode = node => isCallNode(node) && node.name === \"\";\r\nconst isModuleNode = node => isCallNode(node) && node.name === \"$*\";\r\nconst isImportNode = node => isCallNode(node) && node.name === \"$<\";\r\nconst isExportNode = node => isCallNode(node) && node.name === \"$>\";\r\nconst isVarNode = node => isCallNode(node) && node.name === \"$\";\r\nconst isPartialNode = node => isCallNode(node) && node.name == \"$_\";\r\n\r\nconst isCall = x => x && x instanceof Call;\r\nconst isQuot = x => x && x instanceof Quot;\r\nconst isVar = x => x && x instanceof Var;\r\nconst isDatum = x => x && x instanceof Datum;\r\n//const isParam = x => x && x instanceof Var && x.isParam;\r\n\r\nclass Datum {\r\n\tconstructor(type,value) {\r\n\t\tthis.type = type;\r\n\t\tthis.value = value;\r\n\t\tthis.length = 0;\r\n\t}\r\n\tapply() {\r\n\t\treturn this.value;\r\n\t}\r\n}\r\n\r\n// TODO module namespace\r\nclass Context {\r\n\tconstructor(props = {}) {\r\n\t\tthis.core = props.core;\r\n\t\tthis.modules = props.modules || {};\r\n\t\tthis.path = null;\r\n\t\tthis.prefix = \"local\";\r\n\t\tthis.namespace = null;\r\n\t\tthis.stack = [];\r\n\t\tthis.length = 0;\r\n\t\tthis.scope = {};\r\n\t}\r\n\taddVar(count){\r\n\t\tlet v;\r\n\t\tif(count > 1) {\r\n\t\t\t// assigment\r\n\t\t\tv = new Var(this,1,count);\r\n\t\t} else {\r\n\t\t\tconst index = this.stack.lastItem;\r\n\t\t\tif(index.type == 12) {\r\n\t\t\t\tthis.length++;\r\n\t\t\t\tv = new Var(this,2,1);\r\n\t\t\t} else {\r\n\t\t\t\tv = new Var(this,3,1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.append(v);\r\n\t}\r\n\taddModule(length) {\r\n\t\tconst ref = (prefix,ns) => {\r\n\t\t\tthis.prefix = prefix;\r\n\t\t\tthis.namespace = ns;\r\n\t\t\tthis.moduleMap = {[prefix]:ns};\r\n\t\t\tthis.modules[prefix] = {};\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tthis.append(new Call(\"module\",length,ref));\r\n\t}\r\n\taddImport(length) {\r\n\t\tconst ref = (prefix,loc,remap = false) => {\r\n\t\t\t// TODO merge properly\r\n\t\t\tconst ret = run(\"../raddled/\"+loc+\".rdl\")(this);\r\n\t\t\treturn remap ? ret.pipe(mergeMap(cx => {\r\n\t\t\t\tObject.assign(cx.modules[this.prefix],cx.modules[prefix]);\r\n\t\t\t\treturn cx;\r\n\t\t\t})) : ret;\r\n\t\t};\r\n\t\tthis.append(new Call(\"import\",length,ref));\r\n\t}\r\n\taddExport(length){\r\n\t\tconst ref = (qname,type,body) => {\r\n\t\t\tconst { prefix, name } = normalizeName(qname);\r\n\t\t\tconst module = this.modules[prefix];\r\n\t\t\tif(!module) throw new Error(`Module \"${prefix}\" has not been formally declared`);\r\n\t\t\tif(body === undefined) {\r\n\t\t\t\t// bind in core\r\n\t\t\t\tbody = this.core[name];\r\n\t\t\t\tif(!body) {\r\n\t\t\t\t\t//throw new Error(`No entry found for function ${qname}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(type.__length == -1) {\r\n\t\t\t\t\t\tmodule[name] = type(body);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(!module[name]) {\r\n\t\t\t\t\t\t\tmodule[name] = {\r\n\t\t\t\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\t\t\t\tconst type = this[args.length];\r\n\t\t\t\t\t\t\t\t\tif(!type) throw new Error(`No definition found for function ${qname}#${args.length}`);\r\n\t\t\t\t\t\t\t\t\treturn type(body)(...args);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmodule[name][type.__length] = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if(isQuot(body)) {\r\n\t\t\t\t// add a function that serves as a proxy (i.e. can be applied)\r\n\t\t\t\tif(!module[name]) {\r\n\t\t\t\t\tmodule[name] = {\r\n\t\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\t\tconst ref = this[args.length];\r\n\t\t\t\t\t\t\tif(!ref) throw new Error(`Incorrect number of parameters for ${qname}, received ${args.length}, have ${Object.keys(this)}`);\r\n\t\t\t\t\t\t\treturn type(ref.call.bind(ref,self))(...args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tmodule[name][body.length] = body;\r\n\t\t\t} else {\r\n\t\t\t\tmodule[name] = type(body);\r\n\t\t\t}\r\n\t\t\t// perhaps we should just return the export / thing itself\r\n\t\t};\r\n\t\tthis.append(new Call(\"export\",length,ref));\r\n\t}\r\n\tgetRef(qname) {\r\n\t\tconst modules = this.modules;\r\n\t\tconst core = this.core;\r\n\t\tconst { prefix, name } = normalizeName(qname,\"n\");\r\n\t\tconst has = modules.hasOwnProperty(prefix);\r\n\t\tif(has) {\r\n\t\t\tconst ref = modules[prefix][name];\r\n\t\t\tif(ref) return ref;\r\n\t\t}\r\n\t\tif(prefix === \"n\" && core[name]) {\r\n\t\t\treturn core[name];\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Could not resolve ${name} in module ${prefix}. `+ (has ? \"\" : \"Module \"+prefix+\" not found.\"));\r\n\t\t}\r\n\t}\r\n\tisBoundQname(qname) {\r\n\t\tconst { prefix } = prefixAndName(qname);\r\n\t\treturn this.modules.hasOwnProperty(prefix);\r\n\t}\r\n\tgetVarRef(qname) {\r\n\t\t// ignore NS to see if we have prefix\r\n\t\tif(this.isBoundQname(qname)) return this.getRef(qname);\r\n\t\treturn this.scope[qname];\r\n\t}\r\n\tsetVarRef(qname,type,value) {\r\n\t\tthis.scope[qname] = value;\r\n\t}\r\n\taddCall(qname,length,isDef,...args) {\r\n\t\tthis.append(new Call(qname,length,undefined,isDef,args));\r\n\t}\r\n\taddDatum(type,value) {\r\n\t\t// don't append comments\r\n\t\tif(type != 8) this.append(new Datum(type,value));\r\n\t}\r\n\tappend(item){\r\n\t\tthis.stack.push(item);\r\n\t}\r\n\tapply(self,args = []){\r\n\t\t// TODO\r\n\t\t// - first arg is external?\r\n\t\t// - prevent recursion\r\n\t\t// - prevent type checks: just use method for stack/next on each type\r\n\t\t// evaluation stack\r\n\t\tvar stack = [];\r\n\t\tconst len = this.stack.length;\r\n\t\t//for(let i = 0, len = this.stack.length; i < len; i++) {\r\n\t\tconst next = (i,$o) => {\r\n\t\t\tif(i === len) {\r\n\t\t\t\tconst last = stack.pop();\r\n\t\t\t\tif($o) {\r\n\t\t\t\t\t$o.next(last);\r\n\t\t\t\t\t$o.complete();\r\n\t\t\t\t\treturn $o;\r\n\t\t\t\t}\r\n\t\t\t\treturn last;\r\n\t\t\t}\r\n\t\t\tconst last = this.stack[i];\r\n\t\t\tif(isQuot(last)) {\r\n\t\t\t\tstack.push(last.call.bind(last,this));\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t} else if(isCall(last)) {\r\n\t\t\t\tconst qname = last.qname;\r\n\t\t\t\tconst len = last.length;\r\n\t\t\t\tif(stack.length < len) throw new Error(\"Stack underflow\");\r\n\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\tif(qname == \"l3:e\") {\r\n\t\t\t\t\tfor(let i=0;i<len;i++){\r\n\t\t\t\t\t\tconst a = _args[i];\r\n\t\t\t\t\t\tif(typeof a == \"function\") {\r\n\t\t\t\t\t\t\t_args[i] = a(...args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst ret = last.apply(this,_args);\r\n\t\t\t\tif(qname == \"import\") {\r\n\t\t\t\t\tret.subscribe({\r\n\t\t\t\t\t\tcomplete(){\r\n\t\t\t\t\t\t\tnext(i+1,$o);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if(qname == \"export\"){\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstack.push(ret);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else if(isVar(last)) {\r\n\t\t\t\tif(last.isParam) {\r\n\t\t\t\t\t// pop the index, push the arg\r\n\t\t\t\t\tconst index = stack.pop();\r\n\t\t\t\t\tstack.push(args[index - 1]);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// treat vars as Calls\r\n\t\t\t\t\tconst len = last.length;\r\n\t\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\t\tconst ref = last.apply(self,_args);\r\n\t\t\t\t\tif(!last.isAssig) {\r\n\t\t\t\t\t\tstack.push(ref);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstack.push(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else if(isDatum(last)){\r\n\t\t\t\tconst ret = last.apply();\r\n\t\t\t\tstack.push(ret);\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(last);\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t}\r\n\t\t};\r\n\t\tif(isQuot(this)) {\r\n\t\t\treturn next(0);\r\n\t\t} else {\r\n\t\t\treturn Observable.create($o => {\r\n\t\t\t\tnext(0,$o);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tcall(self,...args) {\r\n\t\treturn this.apply(self,args);\r\n\t}\r\n}\r\nclass Var {\r\n\tconstructor(cx,type,length) {\r\n\t\tthis.cx = cx;\r\n\t\t// 1. assignment\r\n\t\t// 2. param\r\n\t\t// 3. var\r\n\t\tthis.isAssig = type == 1;\r\n\t\tthis.isParam = type == 2;\r\n\t\tthis.length = length;\r\n\t}\r\n\tapply(self,args) {\r\n\t\tif(this.isAssig) {\r\n\t\t\tconst hasType = args.length > 2;\r\n\t\t\treturn this.cx.setVarRef(args[0], hasType ? args[1] : null, hasType ? args[2] : args[1]);\r\n\t\t} else {\r\n\t\t\treturn this.cx.getVarRef(args[0]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Quot extends Context {\r\n}\r\n\r\nclass Call {\r\n\tconstructor(qname,length,ref,isDef,args) {\r\n\t\tthis.qname = qname;\r\n\t\tthis.length = length;\r\n\t\tthis.ref = ref;\r\n\t\tthis.isDef = isDef;\r\n\t\tthis.args = args;\r\n\t}\r\n\tapply(cx,args) {\r\n\t\tconst ref = this.ref || cx.getRef(this.qname,this.length);\r\n\t\t// TODO generalize...\r\n\t\tif(this.isDef) {\r\n\t\t\targs.unshift(this.isDef);\r\n\t\t}\r\n\t\treturn ref.apply(this,this.args ? this.args.concat(args) : args);\r\n\t}\r\n}\r\n\r\nexport const prepare = (core,prefix=\"n\",path=\"../raddled/\") => {\r\n\t// pre-compile core\r\n\tconst cx = new Context({core:core,modules:{null:{},l3:l3}});\r\n\treturn run(path+prefix+\".rdl\")(cx);//.pipe(mergeMap(run(path+\"fn.rdl\")));\r\n};\r\n\r\nexport const compile = cx => o => {\r\n\tcx = new Context(cx);\r\n\tconst quots = [cx];\r\n\t// this is a reduction into a single result\r\n\treturn o.pipe(reduce((cx,node) => {\r\n\t\tconst type = node.type;\r\n\t\tif(isClose(type)) {\r\n\t\t\tconst refNode = node.node;\r\n\t\t\tif(isQuotNode(refNode)) {\r\n\t\t\t\tconst dest = quots.pop();\r\n\t\t\t\tquots.lastItem.append(dest);\r\n\t\t\t} else {\r\n\t\t\t\tconst target = quots.lastItem;\r\n\t\t\t\tif(isElementNode(refNode)) {\r\n\t\t\t\t\ttarget.addCall(\"l3:e\",refNode.count(),null,refNode.name);\r\n\t\t\t\t} else if(isListNode(refNode)) {\r\n\t\t\t\t\ttarget.addCall(\"l3:l\",refNode.count(),null);\r\n\t\t\t\t} else if(isMapNode(refNode)) {\r\n\t\t\t\t\t// 1 extra for keys on stack\r\n\t\t\t\t\ttarget.addCall(\"l3:m\",refNode.count(),null);\r\n\t\t\t\t} else if(isVarNode(refNode)) {\r\n\t\t\t\t\t// var or param\r\n\t\t\t\t\tconst count = refNode.count();\r\n\t\t\t\t\t// TODO add default prefix\r\n\t\t\t\t\t// NOTE we know the first child on the node, so we can read the name there\r\n\t\t\t\t\t// HOWEVER this goes against the pure stack-based implementation\r\n\t\t\t\t\tif(count > 1 && refNode.depth == 1 && target.isBoundQname(refNode.first())) {\r\n\t\t\t\t\t\t// private top-level declaration, simply add as export\r\n\t\t\t\t\t\ttarget.addExport(count);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget.addVar(count);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(isModuleNode(refNode)) {\r\n\t\t\t\t\t// handle module insertion\r\n\t\t\t\t\ttarget.addModule(refNode.count());\r\n\t\t\t\t} else if(isImportNode(refNode)) {\r\n\t\t\t\t\t// handle import\r\n\t\t\t\t\ttarget.addImport(refNode.count());\r\n\t\t\t\t} else if(isExportNode(refNode)) {\r\n\t\t\t\t\t// handle export\r\n\t\t\t\t\t// expect type to be compiled to a single Call\r\n\t\t\t\t\ttarget.addExport(refNode.count());\r\n\t\t\t\t} else if(isPartialNode(refNode)) {\r\n\t\t\t\t\t// partial any\r\n\t\t\t\t\ttarget.append($_);\r\n\t\t\t\t} else if(isCallNode(refNode)){\r\n\t\t\t\t\t// handle call\r\n\t\t\t\t\tlet name = refNode.name;\r\n\t\t\t\t\tlet isDef;\r\n\t\t\t\t\t// TODO generalize\r\n\t\t\t\t\t// Use array and seq indifferently\r\n\t\t\t\t\t// and always apply interop higher-order functions.\r\n\t\t\t\t\t// Functions from implementation provide seqs\r\n\t\t\t\t\t// while inline stuff is just arrays\r\n\t\t\t\t\tif(name == \"function\") {\r\n\t\t\t\t\t\tname = \"def\";\r\n\t\t\t\t\t\tisDef = refNode.parent.first();\r\n\t\t\t\t\t\tif(typeof isDef !== \"string\") isDef = \"_\";\r\n\t\t\t\t\t} else if(name == \"\") {\r\n\t\t\t\t\t\tif(refNode.parent.name == \"function\") {\r\n\t\t\t\t\t\t\tname = \"l\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tname = \"seq\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget.addCall(name,refNode.count(),isDef);\r\n\t\t\t\t}\r\n\t\t\t\tconst key = refNode.key;\r\n\t\t\t\tif(key) {\r\n\t\t\t\t\ttarget.addCall(\"l3:a\",1,null,key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if(isLeaf(type)) {\r\n\t\t\tconst target = quots.lastItem;\r\n\t\t\ttarget.addDatum(node.type,node.value);\r\n\t\t\tconst key = node.key;\r\n\t\t\tif(key) {\r\n\t\t\t\ttarget.addCall(\"l3:a\",1,null,key);\r\n\t\t\t}\r\n\t\t} else if(isBranch(type) && isQuotNode(node)) {\r\n\t\t\tconst target = quots.lastItem;\r\n\t\t\t// add quot to scope stack\r\n\t\t\tquots.push(new Quot(cx));\r\n\t\t\tconst key = node.key;\r\n\t\t\tif(key) {\r\n\t\t\t\ttarget.addCall(\"l3:a\",1,null,key);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cx;\r\n\t},cx));\r\n};\r\n\r\nconst runnable = (cx,path) => pipe(toVNodeStreamCurried({withAttrs:true}),compile(cx),switchMap(cx => {\r\n\tcx.path = path;\r\n\treturn cx.apply();\r\n}),mergeMap(x => isObservable(x) ? x : [x]));\r\nexport const run = path => cx => runnable(cx,path)(parse(path));\r\nexport const runString = str => cx => runnable(cx)(parseString(str));\r\n"],"file":"compiler.js"}