{"version":3,"sources":["../src/compiler.js"],"names":["isCallNode","node","type","isQuotNode","isElementNode","isListNode","isMapNode","isModuleNode","name","isImportNode","isExportNode","isVarNode","isPartialNode","isCall","x","Call","isQuot","Quot","isVar","Var","isDatum","Datum","makeAttrMap","a","$attrs","reduce","o","k","v","constructor","value","key","length","apply","Context","props","core","modules","path","prefix","namespace","stack","scope","addVar","count","index","lastItem","append","addModule","ref","ns","moduleMap","addImport","loc","remap","ret","run","pipe","cx","Object","assign","addExport","qname","body","module","Error","undefined","__length","self","args","keys","call","bind","getRef","has","hasOwnProperty","isBoundQname","getVarRef","setVarRef","addCall","isDef","addDatum","item","push","len","next","i","$o","last","pop","complete","_args","splice","subscribe","isParam","isAssig","Observable","create","hasType","unshift","concat","prepare","null","compile","quots","refNode","dest","target","entries","depth","first","$_","parent","runnable","toVNodeStream","runString","str"],"mappings":"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","sourcesContent":["// TODO detect AND/OR and convert to quotation\r\nimport { isLeaf, isBranch, isClose, toVNodeStream } from \"l3n\";\r\nimport { parse, parseString } from \"./parser\";\r\nimport { prefixAndName, normalizeName } from \"./compiler-util\";\r\nimport { Observable, isObservable, pipe } from \"rxjs\";\r\nimport { reduce, switchMap, mergeMap } from \"rxjs/operators\";\r\nimport { $_ /*, papplyAny*/ } from \"./papply\";\r\n\r\n//const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\r\n\r\n//const ifRe = /^(n:)?if$/;\r\n//const andRe = /^(n:)?and$/;\r\n//const orRe = /^(n:)?or$/;\r\n//const andOrRe = /^(n\\.)?(and|or)$/;\r\n\r\nconst isCallNode = node => node.type == 14;\r\nconst isQuotNode = node => node.type == 15;\r\nconst isElementNode = node => node.type == 1;\r\nconst isListNode = node => node.type == 5;\r\nconst isMapNode = node => node.type == 6;\r\n//const isSeqNode = node => isCallNode(node) && node.name === \"\";\r\nconst isModuleNode = node => isCallNode(node) && node.name === \"$*\";\r\nconst isImportNode = node => isCallNode(node) && node.name === \"$<\";\r\nconst isExportNode = node => isCallNode(node) && node.name === \"$>\";\r\nconst isVarNode = node => isCallNode(node) && node.name === \"$\";\r\nconst isPartialNode = node => isCallNode(node) && node.name == \"$_\";\r\n//const isRecursivePartialNode = node => isCallNode(node) && node.name == \"$.\";\r\n//const isIfNode = node => isCallNode(node) && ifRe.test(node.name);\r\n//const isAndNode = node => isCallNode(node) && andRe.test(node.name);\r\n//const isOrNode = node => isCallNode(node) && orRe.test(node.name);\r\n\r\nconst isCall = x => x && x instanceof Call;\r\nconst isQuot = x => x && x instanceof Quot;\r\nconst isVar = x => x && x instanceof Var;\r\nconst isDatum = x => x && x instanceof Datum;\r\n//const isParam = x => x && x instanceof Var && x.isParam;\r\n\r\nconst makeAttrMap = (...a) => ({$attrs:a.reduce((o,[k,v]) => (o[k] = v,o),{})});\r\n\r\nclass Datum {\r\n\tconstructor(type,value,key) {\r\n\t\tthis.type = type;\r\n\t\tthis.value = value;\r\n\t\tthis.key = key;\r\n\t\tthis.length = 0;\r\n\t}\r\n\tapply() {\r\n\t\treturn this.value;\r\n\t}\r\n}\r\n\r\n// TODO module namespace\r\nclass Context {\r\n\tconstructor(props = {},key) {\r\n\t\tthis.core = props.core;\r\n\t\tthis.modules = props.modules || {};\r\n\t\tthis.path = null;\r\n\t\tthis.prefix = \"local\";\r\n\t\tthis.namespace = null;\r\n\t\tthis.stack = [];\r\n\t\tthis.length = 0;\r\n\t\tthis.scope = {};\r\n\t\tthis.key = key;\r\n\t}\r\n\taddVar(count,key){\r\n\t\tlet v;\r\n\t\tif(count > 1) {\r\n\t\t\t// assigment\r\n\t\t\tv = new Var(this,1,count);\r\n\t\t} else {\r\n\t\t\tconst index = this.stack.lastItem;\r\n\t\t\tif(index.type == 12) {\r\n\t\t\t\tthis.length++;\r\n\t\t\t\tv = new Var(this,2,1,key);\r\n\t\t\t} else {\r\n\t\t\t\tv = new Var(this,3,1,key);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.append(v);\r\n\t}\r\n\taddModule(length) {\r\n\t\tconst ref = (prefix,ns) => {\r\n\t\t\tthis.prefix = prefix;\r\n\t\t\tthis.namespace = ns;\r\n\t\t\tthis.moduleMap = {[prefix]:ns};\r\n\t\t\tthis.modules[prefix] = {};\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tthis.append(new Call(\"module\",length,ref));\r\n\t}\r\n\taddImport(length) {\r\n\t\tconst ref = (prefix,loc,remap = false) => {\r\n\t\t\t// TODO merge properly\r\n\t\t\tconst ret = run(\"../raddled/\"+loc+\".rdl\")(this);\r\n\t\t\treturn remap ? ret.pipe(mergeMap(cx => {\r\n\t\t\t\tObject.assign(cx.modules[this.prefix],cx.modules[prefix]);\r\n\t\t\t\treturn cx;\r\n\t\t\t})) : ret;\r\n\t\t};\r\n\t\tthis.append(new Call(\"import\",length,ref));\r\n\t}\r\n\taddExport(length){\r\n\t\tconst ref = (qname,type,body) => {\r\n\t\t\tconst { prefix, name } = normalizeName(qname);\r\n\t\t\tconst module = this.modules[prefix];\r\n\t\t\tif(!module) throw new Error(`Module \"${prefix}\" has not been formally declared`);\r\n\t\t\tif(body === undefined) {\r\n\t\t\t\t// bind in core\r\n\t\t\t\tbody = this.core[name];\r\n\t\t\t\tif(!body) {\r\n\t\t\t\t\t//throw new Error(`No entry found for function ${qname}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif(type.__length == -1) {\r\n\t\t\t\t\t\tmodule[name] = type(body);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(!module[name]) {\r\n\t\t\t\t\t\t\tmodule[name] = {\r\n\t\t\t\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\t\t\t\tconst type = this[args.length];\r\n\t\t\t\t\t\t\t\t\tif(!type) throw new Error(`No definition found for function ${qname}#${args.length}`);\r\n\t\t\t\t\t\t\t\t\treturn type(body)(...args);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmodule[name][type.__length] = type;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if(isQuot(body)) {\r\n\t\t\t\t// add a function that serves as a proxy (i.e. can be applied)\r\n\t\t\t\tif(!module[name]) {\r\n\t\t\t\t\tmodule[name] = {\r\n\t\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\t\tconst ref = this[args.length];\r\n\t\t\t\t\t\t\tif(!ref) throw new Error(`Incorrect number of parameters for ${qname}, received ${args.length}, have ${Object.keys(this)}`);\r\n\t\t\t\t\t\t\treturn type(ref.call.bind(ref,self))(...args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tmodule[name][body.length] = body;\r\n\t\t\t} else {\r\n\t\t\t\tmodule[name] = type(body);\r\n\t\t\t}\r\n\t\t\t// perhaps we should just return the export / thing itself\r\n\t\t};\r\n\t\tthis.append(new Call(\"export\",length,ref));\r\n\t}\r\n\tgetRef(qname) {\r\n\t\tconst modules = this.modules;\r\n\t\tconst core = this.core;\r\n\t\tconst { prefix, name } = normalizeName(qname,\"n\");\r\n\t\tconst has = modules.hasOwnProperty(prefix);\r\n\t\tif(has) {\r\n\t\t\tconst ref = modules[prefix][name];\r\n\t\t\tif(ref) return ref;\r\n\t\t}\r\n\t\tif(prefix === \"n\" && core[name]) {\r\n\t\t\treturn core[name];\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Could not resolve ${name} in module ${prefix}. `+ (has ? \"\" : \"Module \"+prefix+\" not found.\"));\r\n\t\t}\r\n\t}\r\n\tisBoundQname(qname) {\r\n\t\tconst { prefix } = prefixAndName(qname);\r\n\t\treturn this.modules.hasOwnProperty(prefix);\r\n\t}\r\n\tgetVarRef(qname) {\r\n\t\t// ignore NS to see if we have prefix\r\n\t\tif(this.isBoundQname(qname)) return this.getRef(qname);\r\n\t\treturn this.scope[qname];\r\n\t}\r\n\tsetVarRef(qname,type,value) {\r\n\t\tthis.scope[qname] = value;\r\n\t}\r\n\taddCall(qname,length,isDef,key,args) {\r\n\t\tthis.append(new Call(qname,length,undefined,isDef,key,args));\r\n\t}\r\n\taddDatum(type,value,key) {\r\n\t\t// don't append comments\r\n\t\tif(type != 8) this.append(new Datum(type,value,key));\r\n\t}\r\n\tappend(item){\r\n\t\tthis.stack.push(item);\r\n\t}\r\n\tapply(self,args){\r\n\t\t// TODO\r\n\t\t// - first arg is external?\r\n\t\t// - prevent recursion\r\n\t\t// - prevent type checks: just use method for stack/next on each type\r\n\t\t// evaluation stack\r\n\t\tvar stack = [];\r\n\t\tconst len = this.stack.length;\r\n\t\t//for(let i = 0, len = this.stack.length; i < len; i++) {\r\n\t\tconst next = (i,$o) => {\r\n\t\t\tif(i === len) {\r\n\t\t\t\tconst last = stack.pop();\r\n\t\t\t\tif($o) {\r\n\t\t\t\t\t$o.next(last);\r\n\t\t\t\t\t$o.complete();\r\n\t\t\t\t\treturn $o;\r\n\t\t\t\t}\r\n\t\t\t\treturn last;\r\n\t\t\t}\r\n\t\t\tconst last = this.stack[i];\r\n\t\t\t//if(last.key) keys.push(last.key);\r\n\t\t\tconst key = last.key;\r\n\t\t\tif(isQuot(last)) {\r\n\t\t\t\tstack.push(last.call.bind(last,this));\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t} else if(isCall(last)) {\r\n\t\t\t\tconst qname = last.qname;\r\n\t\t\t\tconst len = last.length;\r\n\t\t\t\tif(stack.length < len) throw new Error(\"Stack underflow\");\r\n\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\tconst ret = last.apply(this,_args);\r\n\t\t\t\tif(qname == \"import\") {\r\n\t\t\t\t\tret.subscribe({\r\n\t\t\t\t\t\tcomplete(){\r\n\t\t\t\t\t\t\tnext(i+1,$o);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if(qname == \"export\"){\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstack.push(key ? [key,ret] : ret);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else if(isVar(last)) {\r\n\t\t\t\tif(last.isParam) {\r\n\t\t\t\t\t// pop the index, push the arg\r\n\t\t\t\t\tconst index = stack.pop();\r\n\t\t\t\t\tstack.push(args[index - 1]);\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// treat vars as Calls\r\n\t\t\t\t\tconst len = last.length;\r\n\t\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\t\tconst ref = last.apply(self,_args);\r\n\t\t\t\t\tif(!last.isAssig) {\r\n\t\t\t\t\t\tstack.push(key ? [key,ref] : ref);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstack.push(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn next(i+1,$o);\r\n\t\t\t\t}\r\n\t\t\t} else if(isDatum(last)){\r\n\t\t\t\tconst ret = last.apply();\r\n\t\t\t\tstack.push(key ? [key,ret] : ret);\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(key ? [key,last] : last);\r\n\t\t\t\treturn next(i+1,$o);\r\n\t\t\t}\r\n\t\t};\r\n\t\tif(isQuot(this)) {\r\n\t\t\treturn next(0);\r\n\t\t} else {\r\n\t\t\treturn Observable.create($o => {\r\n\t\t\t\tnext(0,$o);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tcall(self,...args) {\r\n\t\treturn this.apply(self,args);\r\n\t}\r\n}\r\nclass Var {\r\n\tconstructor(cx,type,length) {\r\n\t\tthis.cx = cx;\r\n\t\t// 1. assignment\r\n\t\t// 2. param\r\n\t\t// 3. var\r\n\t\tthis.isAssig = type == 1;\r\n\t\tthis.isParam = type == 2;\r\n\t\tthis.length = length;\r\n\t}\r\n\tapply(self,args) {\r\n\t\tif(this.isAssig) {\r\n\t\t\tconst hasType = args.length > 2;\r\n\t\t\treturn this.cx.setVarRef(args[0], hasType ? args[1] : null, hasType ? args[2] : args[1]);\r\n\t\t} else {\r\n\t\t\treturn this.cx.getVarRef(args[0]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Quot extends Context {\r\n}\r\n\r\nclass Call {\r\n\tconstructor(qname,length,ref,isDef,key,args) {\r\n\t\tthis.qname = qname;\r\n\t\tthis.length = length;\r\n\t\tthis.ref = ref;\r\n\t\tthis.isDef = isDef;\r\n\t\tthis.key = key;\r\n\t\tthis.args = args;\r\n\t}\r\n\tapply(cx,args) {\r\n\t\tconst ref = this.ref || cx.getRef(this.qname,this.length);\r\n\t\t// TODO generalize...\r\n\t\tif(this.isDef) {\r\n\t\t\targs.unshift(this.isDef);\r\n\t\t}\r\n\t\treturn ref.apply(this,this.args ? this.args.concat(args) : args);\r\n\t}\r\n}\r\n\r\nexport const prepare = (core,prefix=\"n\",path=\"../raddled/\") => {\r\n\t// pre-compile core\r\n\tconst cx = new Context({core:core,modules:{null:{}}});\r\n\treturn run(path+prefix+\".rdl\")(cx);//.pipe(mergeMap(run(path+\"fn.rdl\")));\r\n};\r\n\r\nexport const compile = cx => o => {\r\n\tcx = new Context(cx);\r\n\tconst quots = [cx];\r\n\t// this is a reduction into a single result\r\n\treturn o.pipe(reduce((cx,node) => {\r\n\t\tconst type = node.type;\r\n\t\tif(isClose(type)) {\r\n\t\t\tconst refNode = node.node;\r\n\t\t\tif(isQuotNode(refNode)) {\r\n\t\t\t\tconst dest = quots.pop();\r\n\t\t\t\tquots.lastItem.append(dest);\r\n\t\t\t} else {\r\n\t\t\t\tconst target = quots.lastItem;\r\n\t\t\t\tconst key = refNode.key;\r\n\t\t\t\tif(isElementNode(refNode)) {\r\n\t\t\t\t\ttarget.addCall(\"e\",refNode.count(),null,key,[refNode.name,makeAttrMap(refNode.entries())]);\r\n\t\t\t\t} else if(isListNode(refNode)) {\r\n\t\t\t\t\ttarget.addCall(\"l\",refNode.count(),null,key);\r\n\t\t\t\t} else if(isMapNode(refNode)) {\r\n\t\t\t\t\t// 1 extra for keys on stack\r\n\t\t\t\t\ttarget.addCall(\"m\",refNode.count(),null,key);\r\n\t\t\t\t} else if(isVarNode(refNode)) {\r\n\t\t\t\t\t// var or param\r\n\t\t\t\t\tconst count = refNode.count();\r\n\t\t\t\t\t// TODO add default prefix\r\n\t\t\t\t\t// NOTE we know the first child on the node, so we can read the name there\r\n\t\t\t\t\t// HOWEVER this goes against the pure stack-based implementation\r\n\t\t\t\t\tif(count > 1 && refNode.depth == 1 && target.isBoundQname(refNode.first())) {\r\n\t\t\t\t\t\t// private top-level declaration, simply add as export\r\n\t\t\t\t\t\ttarget.addExport(count);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget.addVar(count,key);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(isModuleNode(refNode)) {\r\n\t\t\t\t\t// handle module insertion\r\n\t\t\t\t\ttarget.addModule(refNode.count());\r\n\t\t\t\t} else if(isImportNode(refNode)) {\r\n\t\t\t\t\t// handle import\r\n\t\t\t\t\ttarget.addImport(refNode.count());\r\n\t\t\t\t} else if(isExportNode(refNode)) {\r\n\t\t\t\t\t// handle export\r\n\t\t\t\t\t// expect type to be compiled to a single Call\r\n\t\t\t\t\ttarget.addExport(refNode.count());\r\n\t\t\t\t} else if(isPartialNode(refNode)) {\r\n\t\t\t\t\t// partial any\r\n\t\t\t\t\ttarget.append($_);\r\n\t\t\t\t} else if(isCallNode(refNode)){\r\n\t\t\t\t\t// handle call\r\n\t\t\t\t\tlet name = refNode.name;\r\n\t\t\t\t\tlet isDef;\r\n\t\t\t\t\t// TODO generalize\r\n\t\t\t\t\t// Use array and seq indifferently\r\n\t\t\t\t\t// and always apply interop higher-order functions.\r\n\t\t\t\t\t// Functions from implementation provide seqs\r\n\t\t\t\t\t// while inline stuff is just arrays\r\n\t\t\t\t\tif(name == \"function\") {\r\n\t\t\t\t\t\tname = \"n:def\";\r\n\t\t\t\t\t\tisDef = refNode.parent.first();\r\n\t\t\t\t\t\tif(typeof isDef !== \"string\") isDef = \"_\";\r\n\t\t\t\t\t} else if(name == \"\") {\r\n\t\t\t\t\t\tif(refNode.parent.name == \"function\") {\r\n\t\t\t\t\t\t\tname = \"n:l\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tname = \"n:seq\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget.addCall(name,refNode.count(),isDef,key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if(isLeaf(type)) {\r\n\t\t\tquots.lastItem.addDatum(node.type,node.value,node.key);\r\n\t\t} else if(isBranch(type) && isQuotNode(node)) {\r\n\t\t\t// add quot to scope stack\r\n\t\t\tquots.push(new Quot(cx,node.key));\r\n\t\t}\r\n\t\treturn cx;\r\n\t},cx));\r\n};\r\n\r\nconst runnable = (cx,path) => pipe(toVNodeStream,compile(cx),switchMap(cx => {\r\n\tcx.path = path;\r\n\treturn cx.apply();\r\n}),mergeMap(x => isObservable(x) ? x : [x]));\r\nexport const run = path => cx => runnable(cx,path)(parse(path));\r\nexport const runString = str => cx => runnable(cx)(parseString(str));\r\n"],"file":"compiler.js"}