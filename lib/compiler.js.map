{"version":3,"sources":["../src/compiler.js"],"names":["isCallNode","node","type","isQuotNode","isModuleNode","name","isImportNode","isExportNode","isVarNode","isPartialNode","isCall","x","Call","isQuot","Context","isVar","Var","NOOP","__noop","constructor","props","modules","stack","length","scope","refsToResolve","addVar","count","v","index","lastItem","append","addModule","ref","prefix","addImport","ns","loc","self","pipe","toVNodeStream","compile","cx","ret","apply","module","Object","entries","forEach","k","next","complete","addExport","qname","body","Error","args","keys","$_","getRef","hasOwnProperty","rts","def","ReplaySubject","isBoundQname","getVarRef","setVarRef","value","addCall","addDatum","item","push","len","i","last","pop","subscribe","_args","splice","isParam","isAssig","hasType","sub","o","quots","refNode","dest","target","depth","first","run"],"mappings":"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","sourcesContent":["// TODO detect AND/OR and convert to quotation\r\nimport { isLeaf, isBranch, isClose, toVNodeStream } from \"l3n\";\r\nimport { parse } from \"./parser\";\r\nimport { prefixAndName, normalizeName } from \"./compiler-util\";\r\nimport { ReplaySubject, isObservable } from \"rxjs\";\r\nimport { reduce, map, mergeMap, mergeAll } from \"rxjs/operators\";\r\nimport { $_, papplyAny } from \"./papply\";\r\n\r\n//const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\r\n\r\n//const ifRe = /^(n:)?if$/;\r\n//const andRe = /^(n:)?and$/;\r\n//const orRe = /^(n:)?or$/;\r\n\r\nconst isCallNode = node => node && node.type == 14;\r\nconst isQuotNode = node => node && node.type == 15;\r\n//const isSeqNode = node => isCallNode(node) && node.name === \"\";\r\nconst isModuleNode = node => isCallNode(node) && node.name === \"$*\";\r\nconst isImportNode = node => isCallNode(node) && node.name === \"$<\";\r\nconst isExportNode = node => isCallNode(node) && node.name === \"$>\";\r\nconst isVarNode = node => isCallNode(node) && node.name === \"$\";\r\nconst isPartialNode = node => isCallNode(node) && node.name == \"$_\";\r\n//const isRecursivePartialNode = node => isCallNode(node) && node.name == \"$.\";\r\n//const isIfNode = node => isCallNode(node) && ifRe.test(node.name);\r\n//const isAndNode = node => isCallNode(node) && andRe.test(node.name);\r\n//const isOrNode = node => isCallNode(node) && orRe.test(node.name);\r\n\r\nconst isCall = x => x && x instanceof Call;\r\nconst isQuot = x => x && x instanceof Context;\r\nconst isVar = x => x && x instanceof Var;\r\n//const isParam = x => x && x instanceof Var && x.isParam;\r\nconst NOOP = {__noop:true};\r\n\r\n// TODO module namespace\r\nclass Context {\r\n\tconstructor(props = {}) {\r\n\t\tthis.modules = props.modules || {};\r\n\t\tthis.stack = [];\r\n\t\tthis.length = 0;\r\n\t\tthis.scope = {};\r\n\t\tthis.refsToResolve = {};\r\n\t}\r\n\taddVar(count){\r\n\t\tlet v;\r\n\t\tif(count > 1) {\r\n\t\t\t// assigment\r\n\t\t\tv = new Var(this,1,count);\r\n\t\t} else {\r\n\t\t\tconst index = this.stack.lastItem;\r\n\t\t\tif(typeof index == \"number\") {\r\n\t\t\t\tthis.length++;\r\n\t\t\t\tv = new Var(this,2,1);\r\n\t\t\t} else {\r\n\t\t\t\tv = new Var(this,3,1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.append(v);\r\n\t}\r\n\taddModule(length) {\r\n\t\tconst ref = prefix => {\r\n\t\t\tthis.modules[prefix] = {};\r\n\t\t\treturn NOOP;\r\n\t\t};\r\n\t\tthis.append(new Call(\"module\",length,ref));\r\n\t}\r\n\taddImport(length) {\r\n\t\tconst ref = (prefix,ns,loc) => {\r\n\t\t\tif(length == 2) loc = ns;\r\n\t\t\tthis.refsToResolve[prefix] = {};\r\n\t\t\t// TODO merge properly\r\n\t\t\tconst self = this;\r\n\t\t\treturn parse(\"../raddled/\"+loc+\".rdl\").pipe(toVNodeStream,x => compile(x,this),mergeMap(cx => {\r\n\t\t\t\tconst ret = cx.apply();\r\n\t\t\t\t//console.log(ret);\r\n\t\t\t\treturn ret;\r\n\t\t\t}),map(() => {\r\n\t\t\t\tconst module = self.modules[prefix];\r\n\t\t\t\tObject.entries(self.refsToResolve[prefix]).forEach(([k,v]) => {\r\n\t\t\t\t\tv.next(module[k]);\r\n\t\t\t\t\tv.complete();\r\n\t\t\t\t});\r\n\t\t\t\treturn self;\r\n\t\t\t}));\r\n\t\t};\r\n\t\tthis.append(new Call(\"import\",length,ref));\r\n\t}\r\n\taddExport(length){\r\n\t\tconst ref = (qname,type,body) => {\r\n\t\t\tconst { prefix, name } = normalizeName(qname);\r\n\t\t\tconst module = this.modules[prefix];\r\n\t\t\tif(!module) throw new Error(`Module \"${prefix}\" has not been formally declared`);\r\n\t\t\tif(isQuot(body)) {\r\n\t\t\t\t// add an object that serves as a proxy (i.e. can be applied)\r\n\t\t\t\tif(!module[name]) module[name] = {\r\n\t\t\t\t\tapply(self,args) {\r\n\t\t\t\t\t\tconst ref = this[args.length];\r\n\t\t\t\t\t\tif(!ref) throw new Error(`Incorrect number of parameters for ${qname}, received ${args.length}, have ${Object.keys(this)}`);\r\n\t\t\t\t\t\treturn ref.apply(self,args);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t// TODO add type\r\n\t\t\t\tmodule[name][body.length] = body;\r\n\t\t\t} else {\r\n\t\t\t\tmodule[name] = body;\r\n\t\t\t}\r\n\t\t\treturn NOOP;\r\n\t\t};\r\n\t\tthis.append(new Call(\"export\",length,length == 2 ? papplyAny(ref,$_,() => {},$_) : ref));\r\n\t}\r\n\tgetRef(qname) {\r\n\t\tconst modules = this.modules;\r\n\t\tconst { prefix, name } = normalizeName(qname,\"n\");\r\n\t\tif(modules.hasOwnProperty(prefix)) {\r\n\t\t\treturn modules[prefix][name];\r\n\t\t} else {\r\n\t\t\t//console.log(\"no module found\",prefix);\r\n\t\t\t// deferring module entry as a ReplaySubject\r\n\t\t\tconst rts = this.refsToResolve;\r\n\t\t\tif(!rts.hasOwnProperty(prefix)) throw new Error(`Import of prefix ${prefix} not yet encountered`);\r\n\t\t\tconst def = new ReplaySubject();\r\n\t\t\tif(!rts[prefix].hasOwnProperty(name)) rts[prefix][name] = def;\r\n\t\t\treturn def;\r\n\t\t}\r\n\t}\r\n\tisBoundQname(qname) {\r\n\t\tconst { prefix } = prefixAndName(qname);\r\n\t\treturn this.modules.hasOwnProperty(prefix) || this.refsToResolve.hasOwnProperty(prefix);\r\n\t}\r\n\tgetVarRef(qname) {\r\n\t\t// ignore NS to see if we have prefix\r\n\t\tif(this.isBoundQname(qname)) return this.getRef(qname);\r\n\t\treturn this.scope[qname];\r\n\t}\r\n\tsetVarRef(qname,type,value) {\r\n\t\tthis.scope[qname] = value;\r\n\t\treturn NOOP;\r\n\t}\r\n\taddCall(qname,length) {\r\n\t\t//if(!qname) console.trace(qname,length);\r\n\t\tthis.append(new Call(qname,length));\r\n\t}\r\n\taddDatum(type,value) {\r\n\t\tif(type !== 8) this.append(value);\r\n\t}\r\n\tappend(item){\r\n\t\tthis.stack.push(item);\r\n\t}\r\n\tapply(self,args){\r\n\t\t// TODO first arg is external?\r\n\t\t// evaluation stack\r\n\t\tvar stack = [];\r\n\t\tvar ret = new ReplaySubject();\r\n\t\tconst len = this.stack.length;\r\n\t\t//for(let i = 0, len = this.stack.length; i < len; i++) {\r\n\t\tconst next = (i) => {\r\n\t\t\tif(i == len) {\r\n\t\t\t\tconst last = stack.pop();\r\n\t\t\t\tif(last instanceof ReplaySubject) {\r\n\t\t\t\t\tlast.subscribe(ret);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tret.next(last);\r\n\t\t\t\t\tret.complete();\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tconst last = this.stack[i];\r\n\t\t\tif(isQuot(last)) {\r\n\t\t\t\tstack.push(last);\r\n\t\t\t\tnext(i+1);\r\n\t\t\t} else if(isCall(last)) {\r\n\t\t\t\tconst len = last.length;\r\n\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\t// TODO original stack as Observable\r\n\t\t\t\t// if last.ref is Subject, evaluation must be deferred:\r\n\t\t\t\t// take next from the stack when ref is resolved\r\n\t\t\t\tlast.apply(this,_args).subscribe(ret => {\r\n\t\t\t\t\tif(isObservable(ret)) {\r\n\t\t\t\t\t\tret.subscribe({\r\n\t\t\t\t\t\t\tcomplete(){\r\n\t\t\t\t\t\t\t\tnext(i+1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(ret !== NOOP) stack.push(ret);\r\n\t\t\t\t\t\tnext(i+1);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else if(isVar(last)) {\r\n\t\t\t\tif(last.isParam) {\r\n\t\t\t\t\t// pop the index, push the arg\r\n\t\t\t\t\tconst index = stack.pop();\r\n\t\t\t\t\tstack.push(args[index - 1]);\r\n\t\t\t\t\tnext(i+1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// treat vars as Calls\r\n\t\t\t\t\tconst len = last.length;\r\n\t\t\t\t\tconst _args = stack.splice(-len,len);\r\n\t\t\t\t\tconst ref = last.apply(self,_args);\r\n\t\t\t\t\tif(last.isAssig) {\r\n\t\t\t\t\t\tnext(i+1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(ref instanceof ReplaySubject) {\r\n\t\t\t\t\t\t\tref.subscribe((x) => {\r\n\t\t\t\t\t\t\t\tstack.push(x);\r\n\t\t\t\t\t\t\t\tnext(i+1);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstack.push(ref);\r\n\t\t\t\t\t\t\tnext(i+1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(last);\r\n\t\t\t\tnext(i+1);\r\n\t\t\t}\r\n\t\t};\r\n\t\tnext(0);\r\n\t\treturn ret;\r\n\t}\r\n}\r\nclass Var {\r\n\tconstructor(cx,type,length) {\r\n\t\tthis.cx = cx;\r\n\t\t// 1. assignment\r\n\t\t// 2. param\r\n\t\t// 3. var\r\n\t\tthis.isAssig = type == 1;\r\n\t\tthis.isParam = type == 2;\r\n\t\tthis.length = length;\r\n\t}\r\n\tapply(self,args) {\r\n\t\tif(this.isAssig) {\r\n\t\t\tconst hasType = args.length > 2;\r\n\t\t\treturn this.cx.setVarRef(args[0], hasType ? args[1] : null, hasType ? args[2] : args[1]);\r\n\t\t} else {\r\n\t\t\treturn this.cx.getVarRef(args[0]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Call {\r\n\tconstructor(qname,length,ref) {\r\n\t\tthis.qname = qname;\r\n\t\tthis.length = length;\r\n\t\tthis.ref = ref;\r\n\t}\r\n\tapply(cx,args) {\r\n\t\tconst ref = this.ref || cx.getRef(this.qname,this.length);\r\n\t\tif(ref instanceof ReplaySubject) {\r\n\t\t\treturn ref.pipe(map(ref => ref.apply(this,args)));\r\n\t\t} else {\r\n\t\t\tconst ret = ref.apply(this,args);\r\n\t\t\tlet sub = new ReplaySubject();\r\n\t\t\tsub.next(ret);\r\n\t\t\tsub.complete();\r\n\t\t\treturn sub;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const compile = cx => o => {\r\n\tcx = new Context(cx);\r\n\tconst quots = [cx];\r\n\t// this is a reduction into a single result\r\n\treturn o.pipe(reduce((cx,node) => {\r\n\t\tconst type = node.type;\r\n\t\tif(isClose(type)) {\r\n\t\t\tconst refNode = node.node;\r\n\t\t\tif(isQuotNode(refNode)) {\r\n\t\t\t\tconst dest = quots.pop();\r\n\t\t\t\tquots.lastItem.append(dest);\r\n\t\t\t} else {\r\n\t\t\t\tconst target = quots.lastItem;\r\n\t\t\t\tif(isVarNode(refNode)) {\r\n\t\t\t\t\t// var or param\r\n\t\t\t\t\tconst count = refNode.count();\r\n\t\t\t\t\t// TODO add default prefix\r\n\t\t\t\t\t// NOTE we know the first child on the node, so we can read the name there\r\n\t\t\t\t\t// HOWEVER this goes against the pure stack-based implementation\r\n\t\t\t\t\tif(count > 1 && refNode.depth == 1 && target.isBoundQname(refNode.first())) {\r\n\t\t\t\t\t\t// private top-level declaration, simply add as export\r\n\t\t\t\t\t\ttarget.addExport(count);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget.addVar(count);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if(isModuleNode(refNode)) {\r\n\t\t\t\t\t// handle module insertion\r\n\t\t\t\t\ttarget.addModule(refNode.count());\r\n\t\t\t\t} else if(isImportNode(refNode)) {\r\n\t\t\t\t\t// handle import\r\n\t\t\t\t\ttarget.addImport(refNode.count());\r\n\t\t\t\t} else if(isExportNode(refNode)) {\r\n\t\t\t\t\t// handle export\r\n\t\t\t\t\t// expect type to be compiled to a single Call\r\n\t\t\t\t\ttarget.addExport(refNode.count());\r\n\t\t\t\t} else if(isPartialNode(refNode)) {\r\n\t\t\t\t\t// partial any\r\n\t\t\t\t\ttarget.append($_);\r\n\t\t\t\t} else if(isCallNode(refNode)){\r\n\t\t\t\t\t// handle call\r\n\t\t\t\t\ttarget.addCall(refNode.name,refNode.count());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if(isLeaf(type)) {\r\n\t\t\tquots.lastItem.addDatum(node.type,node.value);\r\n\t\t} else if(isBranch(type) && isQuotNode(node)) {\r\n\t\t\t// add quot to scope stack\r\n\t\t\tquots.push(new Context(cx));\r\n\t\t}\r\n\t\treturn cx;\r\n\t},cx));\r\n};\r\n\r\nexport const run = (o,cx) => compile(o,cx).pipe(map(cx => cx.apply()),mergeAll());\r\n"],"file":"compiler.js"}